<?xml version="1.0" encoding="UTF-8"?>
<!-- This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 
	License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/1.0/ 
	or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 
	94305, USA. License: http://rhizomik.net/redefer/xsd2owl.xsl.rdf -->
<xsl:stylesheet version="2.0"
	xmlns:xo="http://rhizomik.net/redefer/xsl/xsd2owl-functions.xsl"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
	xmlns:owl="http://www.w3.org/2002/07/owl#">

	<xsl:import href="xsd2owl-functions.xsl" />
	<xsl:output media-type="text/xml" version="1.0" encoding="UTF-8"
		indent="yes" use-character-maps="owl" />

	<xsl:strip-space elements="*" />

	<xsl:character-map name="owl">
		<xsl:output-character character="&amp;" string="&amp;" />
	</xsl:character-map>

	<!-- Used to avoid repeated creation of the properties implicitly created 
		as elements or attributes inside complexTypes, groups and attribute groups 
		declarations and contains(xo:makeRDFAbsoluteRefFunc(@name),'http://www.w3.org/2001/XMLSchema#') 
		<xsl:key name="distinctElements" match="//xsd:element[@name and (ancestor::xsd:complexType 
		or ancestor::xsd:group) and not(xo:existsElemOrAtt(/xsd:schema, @name))]" 
		use="@name"/> <xsl:key name="distinctAttributes" match="//xsd:attribute[@name 
		and (ancestor::xsd:complexType or ancestor::xsd:attributeGroup) and not(xo:existsElemOrAtt(/xsd:schema, 
		@name))]" use="@name"/ -->

	<!-- Used to avoid repeated creation of the properties implicitly created 
		as elements or attributes inside complexTypes, groups and attribute groups 
		declarations -->
	<xsl:key name="distinctProperties"
		match="//xsd:element[@name and (ancestor::xsd:complexType or ancestor::xsd:group) and 
																		not(xo:existsElemOrAtt(/xsd:schema, @name))] |
											  //xsd:attribute[@name and (ancestor::xsd:complexType or ancestor::xsd:attributeGroup) and
																		not(xo:existsElemOrAtt(/xsd:schema, @name))]"
		use="@name" />

	<!-- Get the default namespace and build a entity definition for it -->
	<xsl:variable name="targetNamespace">
		<xsl:value-of select="/xsd:schema/@targetNamespace" />
	</xsl:variable>
	<xsl:variable name="baseEntity">
		<xsl:text disable-output-escaping="yes">&amp;</xsl:text>
		<xsl:for-each select="/xsd:schema/namespace::*">
			<xsl:if test=". = $targetNamespace">
				<xsl:value-of select="name()" />
			</xsl:if>
		</xsl:for-each>
		<xsl:text disable-output-escaping="yes">;</xsl:text>
	</xsl:variable>

	<!-- Match the xsd:schema element to generate the entity definitions from 
		the used namespaces. Then, the rdf:RDF element and the the ontology subelement 
		are generated. Finally, the rest of the XML Schema is processed. -->
	<xsl:template match="/xsd:schema">
		<!-- Generate entity definitions for each namespace -->
		<xsl:text disable-output-escaping="yes">&#10;&lt;!DOCTYPE rdf:RDF [&#10;</xsl:text>
		<!-- Allways include xsd entity and thus ignore if also defined in input 
			xsd -->
		<xsl:text disable-output-escaping="yes">&#09;&lt;!ENTITY xsd 'http://www.w3.org/2001/XMLSchema#'&gt;&#10;</xsl:text>
		<xsl:for-each select="namespace::*[not(name()='' or name()='xsd')]">
			<xsl:text disable-output-escaping="yes">&#09;&lt;!ENTITY </xsl:text>
			<xsl:value-of select="name()" />
			<xsl:text disable-output-escaping="yes"> '</xsl:text>
			<xsl:choose>
				<xsl:when test=". = $targetNamespace">
					<xsl:text disable-output-escaping="yes">#</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="." />
					<xsl:if test="not(contains(.,'#'))">
						<xsl:text disable-output-escaping="yes">#</xsl:text>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text disable-output-escaping="yes">'&gt;&#10;</xsl:text>
		</xsl:for-each>
		<xsl:text disable-output-escaping="yes">]&gt;&#10;</xsl:text>
		<!-- Build the rdf:RDF element with the namespace declarations for the 
			declared namespace entities -->
		<rdf:RDF>
			<!-- Detect the namespaces used in the XMLSchema that must be copied to 
				the OWL ontology -->
			<xsl:variable name="used_namespaces">
				<xsl:for-each
					select="namespace::*[not(name()='' or name()='xsd' or name()='xml')]">
					<xsl:element name="{name()}:x" namespace="&#38;{name()};" />
				</xsl:for-each>
			</xsl:variable>
			<!-- Copy the required namespaces collected in the "used_namespaces" variable 
				declaration, which acts as their temporal container -->
			<!--xsl:copy-of select="node-set($used_namespaces)/*/namespace::*"/ -->
			<xsl:copy-of select="$used_namespaces/*/namespace::*" />
			<owl:Ontology rdf:about="">
				<rdfs:comment>OWL ontology generated by the xsd2owl XML Style Sheet
					(http://rhizomik.net/redefer)</rdfs:comment>
				<!-- Create the owl:imports elements corresponding to the xsd:import 
					elements -->
				<xsl:for-each
					select="./xsd:import[@namespace!='http://www.w3.org/2001/XMLSchema']">
					<xsl:variable name="namespaceAtt">
						<xsl:value-of select="@namespace" />
					</xsl:variable>
					<!-- If there is an alias for the namespace, use it. Otherwise, use 
						the namespace URI -->
					<xsl:variable name="importRef">
						<xsl:for-each select="namespace::*">
							<xsl:if test=". = $namespaceAtt">
								<xsl:value-of select="name()" />
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="not($importRef='')">
							<owl:imports rdf:resource="&amp;{$importRef};" />
						</xsl:when>
						<xsl:otherwise>
							<owl:imports rdf:resource="{$namespaceAtt}" />
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</owl:Ontology>
			<xsl:apply-templates />

			<!-- Generate the OWL class definitions for the complexTypes totally declared 
				inside other ones, in order to avoid repetitions: and generate-id()=generate-id(key('newClasses',@name)) -->
			<!--xsl:for-each select="//xsd:element[not(@type or @ref) and (ancestor::xsd:complexType 
				or ancestor::xsd:group)]/xsd:complexType"> <xsl:call-template name="processComplexType"/> 
				</xsl:for-each -->

			<!-- Add the any ObjectProperty for xsd:any -->
			<owl:ObjectProperty rdf:ID="any" />

			<!-- Explicitly create the new properties defined inside complexTypes, 
				groups and attributGroups using the key to select only distinct ones -->
			<xsl:for-each
				select="//xsd:element[@name and (ancestor::xsd:complexType or ancestor::xsd:group) and generate-id()=generate-id(key('distinctProperties',@name)[1])] | 
												//xsd:attribute[@name and (ancestor::xsd:complexType or ancestor::xsd:attributeGroup) and generate-id()=generate-id(key('distinctProperties',@name)[1])]">
				<xsl:sort select="@name" order="ascending" />
				<!-- If it can be determined to be an element or attribute associated 
					with datatype only values (i.e. simpleTypes) then map it to a owl:DatatypeProperty. 
					If it is associated with objectype only values (i.e. complexTypes) then map 
					it to owl:ObjectProperty. Otherwise, use rdf:Property to cope with both kinds 
					of values -->
				<xsl:variable name="currentName">
					<xsl:value-of select="@name" />
				</xsl:variable>
				<xsl:choose>
					<!--xsl:when test="xo:isDatatype(.,//xsd:simpleType[@name],namespace::*) 
						and not(xo:isObjectype(.,//xsd:complexType[@name],namespace::*))" -->
					<xsl:when
						test="xo:allDatatype(//xsd:element[@name=$currentName and (ancestor::xsd:complexType or ancestor::xsd:group)] | 
										 //xsd:attribute[@name=$currentName and (ancestor::xsd:complexType or ancestor::xsd:attributeGroup)], 
										 //xsd:complexType[@name], namespace::*)">
						<owl:DatatypeProperty rdf:ID="{@name}" />
					</xsl:when>
					<!--xsl:when test="xo:isObjectype(.,//xsd:complexType[@name],namespace::*) 
						and not(xo:isDatatype(.,//xsd:simpleType[@name],namespace::*))" -->
					<xsl:when
						test="xo:allObjectype(//xsd:element[@name=$currentName and (ancestor::xsd:complexType or ancestor::xsd:group)] | 
										 //xsd:attribute[@name=$currentName and (ancestor::xsd:complexType or ancestor::xsd:attributeGroup)],
										 //xsd:simpleType[@name], namespace::*)">
						<owl:ObjectProperty rdf:ID="has{@name}" />
					</xsl:when>
					<xsl:otherwise>
						<rdf:Property rdf:ID="{@name}" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
		</rdf:RDF>
		
		
	</xsl:template>
	
	<xsl:template
		match="xsd:schema/xsd:element[@name]|xsd:schema/xsd:attribute[@name and not(xo:existsElem(/xsd:schema/xsd:element,@name))]">
		<!-- Use the same criteria than for elements and attributed defined inside 
			complexTypes, groups and attributGroups -->
		<xsl:choose>
			<xsl:when
				test="xo:isDatatype(.,//xsd:simpleType[@name],namespace::*) and 
							 not(xo:isObjectype(.,//xsd:complexType[@name],namespace::*))">
				<owl:DatatypeProperty rdf:ID="{@name}">
					<xsl:call-template name="processElemDef" />
				</owl:DatatypeProperty>
			</xsl:when>
			<xsl:when
				test="xo:isObjectype(.,//xsd:complexType[@name],namespace::*) and 
							not(xo:isDatatype(.,//xsd:simpleType[@name],namespace::*))">
				<owl:ObjectProperty rdf:ID="{@name}">
					<xsl:call-template name="processElemDef" />
				</owl:ObjectProperty>
			</xsl:when>
			<xsl:otherwise>
				<rdf:Property rdf:ID="{@name}">
					<xsl:call-template name="processElemDef" />
				</rdf:Property>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="processElemDef">
		<!-- The class hierarchy is defined by the substitutionGroup attribute -->
		<xsl:if test="@substitutionGroup">
			<rdfs:subPropertyOf rdf:resource="{xo:rdfUri(@substitutionGroup, namespace::*)}" />
		</xsl:if>
		<!-- The type attribute or the embeded complexType define equivalent classes -->
		<xsl:choose>
			<xsl:when test="@type">
				<rdfs:range
					rdf:resource="{xo:rangeUri(., //xsd:simpleType[@name], namespace::*)}" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="./xsd:complexType">
					<!-- Generate anonymous class definition from complexType -->
					<rdfs:range>
						<xsl:apply-templates />
					</rdfs:range>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<!-- Match XML Schema complexType or group definitions to generate classes, 
		if the embededType has a value this is a complex type defined inside and 
		element, distinguish its name from the name of the element using the embededType 
		param value -->
	<xsl:template name="processComplexType"
		match="xsd:complexType|xsd:group|xsd:attributeGroup">
		<xsl:if test="@name">
			<owl:Class rdf:ID="{@name}">
				<xsl:apply-templates />
			</owl:Class>
		</xsl:if>
		<xsl:if test="not(@name)">
			<xsl:choose>
				<xsl:when test="parent::xsd:element[@name]">
					<owl:Class rdf:ID="{../@name}Type">
						<xsl:apply-templates />
					</owl:Class>
				</xsl:when>
				<xsl:otherwise>
					<owl:Class>	<!--rdf:ID="_:{generate-id()}" -->
						<xsl:apply-templates />
					</owl:Class>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>

</xsl:stylesheet>
